# Algorithm

> book : 보통의 취준생을 위한 코딩테스트 with 파이썬
>
> baekjoon : https://www.acmicpc.net/
>
> codeforces : https://codeforces.com/
>
> solved : https://solved.ac/

## Intro

* 내 실력보다 어려운 문제에 대한 도전 두려워하지 않기
* 문제를 보고 정답을 모를 때 해답을 보며 나의 것으로 만들기
* 풀어본 문제에 대하여 사색의 시간 갖기

---

### 0-1. 시간복잡도의 빅오 표현법

* n값에 따른 컴퓨터 연산 횟수를 함수로 나타냈을 때의 표현법
* O(n!) - O(2<sup>n</sup>) - O(n<sup>2</sup>) - O(n*log<sup>n</sup>) - O(n) - O(log<sup>n</sup>) - O(1) 순으로 n의 값이 커져도 연산 횟수가 줄어듬
* O(1)에 가까운 시간복잡도를 사용하여 개발 해야 좋은 프로그램이 나옴

#### 0-1-1. O(n)

* n값에 따라서 최악의 경우 **최대 n번의 연산**을 해야하는 경우
* [3,6,7,2]에서 3을 찾으려면 한번에, 2를 찾으려면 4번, 즉 n번이 걸림

#### 0-1-2. O(log<sup>n</sup>)

* n값에 따라서 최악의 경우 **최대 log<sup>n</sup>번의 연산**을 해야하는 경우
* 이분탐색 
  * 정렬 되어있을 때 사용 가능한 탐색 방법
  * 한 번의 탐색마다 탐색 해야될 수가 대략 1/2로 줄어듬
  * n=10인 집합에서 x를 가장 늦게 찾는 경우는 log<sub>2</sub>10=3.32번(올림해서 4번)임
  * 참고사이트 : https://velog.io/@kimdukbae/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search

#### 0-1-3. O(n<sup>2</sup>)

* n값에 따라서 최악의 경우 **최대 n<sup>2</sup>번의 연산**을 해야하는 경우

#### 0-1-4. O(2<sup>n</sup>)

* n값에 따라서 최악의 경우 **최대 2<sup>n</sup>번의 연산**을 해야하는 경우

#### 0-1-5. O(n!)

* n값에 따라서 최악의 경우 **최대 n!번의 연산**을 해야하는 경우

---

## 1. Array List

* 삽입과 삭제
  * 원하는 값을 삽입하거나 삭제할 때 최대 n번의 이동을 통해 자리를 만들어야 하므로 시간 복잡도는 `O(n)`이 됨
  * 문제가 요구하는 연산 횟수 안에서 해결하기 위해서는 항상 조심해야 함
  * 참고사이트 : https://velog.io/@gillog/%EB%B0%B0%EC%97%B4-%EB%A6%AC%EC%8A%A4%ED%8A%B8Array-List

---

## 2. Linked List

* 원하는 위치값으로 O(1)의 접근 불가능
* 각각의 노드들은 저장할 값과 next를 통해 다음 노드의 위치를 저장해 둔 방식으로 원하는 값을 찾을 때 O(n)의 시간복잡도 소요
* 삽입과 삭제
  * 다음 노드의 위치를 저장할 next값만 변경해주면 됨
  * 삽입 공간 만들 필요 없음
  * 삽입/삭제 시 시간복잡도는 O(1)이 소요되지만 삽입/삭제할 위치를 모른다면 O(n)의 시간복잡도 소요됨