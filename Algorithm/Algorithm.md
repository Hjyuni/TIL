# Algorithm

> book : 보통의 취준생을 위한 코딩테스트 with 파이썬
>
> baekjoon : https://www.acmicpc.net/
>
> codeforces : https://codeforces.com/
>
> solved : https://solved.ac/

## Intro

* 내 실력보다 어려운 문제에 대한 도전 두려워하지 않기
* 문제를 보고 정답을 모를 때 해답을 보며 나의 것으로 만들기
* 풀어본 문제에 대하여 사색의 시간 갖기

---

### 0-1. 시간복잡도의 빅오 표현법

* n값에 따른 컴퓨터 연산 횟수를 함수로 나타냈을 때의 표현법
* O(n!) - O(2<sup>n</sup>) - O(n<sup>2</sup>) - O(n*log<sup>n</sup>) - O(n) - O(log<sup>n</sup>) - O(1) 순으로 n의 값이 커져도 연산 횟수가 줄어듬
* O(1)에 가까운 시간복잡도를 사용하여 개발 해야 좋은 프로그램이 나옴

#### 0-1-1. O(n)

* n값에 따라서 최악의 경우 **최대 n번의 연산**을 해야하는 경우
* [3,6,7,2]에서 3을 찾으려면 한번에, 2를 찾으려면 4번, 즉 n번이 걸림

#### 0-1-2. O(log<sup>n</sup>)

* n값에 따라서 최악의 경우 **최대 log<sup>n</sup>번의 연산**을 해야하는 경우
* 이분탐색 
  * 정렬 되어있을 때 사용 가능한 탐색 방법
  * 한 번의 탐색마다 탐색 해야될 수가 대략 1/2로 줄어듬
  * n=10인 집합에서 x를 가장 늦게 찾는 경우는 log<sub>2</sub>10=3.32번(올림해서 4번)임
  * 참고사이트 : https://velog.io/@kimdukbae/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search

#### 0-1-3. O(n<sup>2</sup>)

* n값에 따라서 최악의 경우 **최대 n<sup>2</sup>번의 연산**을 해야하는 경우

#### 0-1-4. O(2<sup>n</sup>)

* n값에 따라서 최악의 경우 **최대 2<sup>n</sup>번의 연산**을 해야하는 경우

#### 0-1-5. O(n!)

* n값에 따라서 최악의 경우 **최대 n!번의 연산**을 해야하는 경우